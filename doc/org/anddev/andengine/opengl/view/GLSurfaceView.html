<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_24) on Wed Sep 05 11:06:59 CEST 2012 -->
<TITLE>
GLSurfaceView
</TITLE>

<META NAME="date" CONTENT="2012-09-05">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="GLSurfaceView";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/GLSurfaceView.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../../org/anddev/andengine/opengl/view/EGLConfigChooser.html" title="interface in org.anddev.andengine.opengl.view"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.EglHelper.html" title="class in org.anddev.andengine.opengl.view"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../../index.html?org/anddev/andengine/opengl/view/GLSurfaceView.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="GLSurfaceView.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;<A HREF="#nested_class_summary">NESTED</A>&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
org.anddev.andengine.opengl.view</FONT>
<BR>
Class GLSurfaceView</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../../../resources/inherit.gif" ALT="extended by ">SurfaceView
      <IMG SRC="../../../../../resources/inherit.gif" ALT="extended by "><B>org.anddev.andengine.opengl.view.GLSurfaceView</B>
</PRE>
<DL>
<DT><B>Direct Known Subclasses:</B> <DD><A HREF="../../../../../org/anddev/andengine/opengl/view/RenderSurfaceView.html" title="class in org.anddev.andengine.opengl.view">RenderSurfaceView</A></DD>
</DL>
<HR>
<DL>
<DT><PRE>public class <B>GLSurfaceView</B><DT>extends SurfaceView</DL>
</PRE>

<P>
An implementation of SurfaceView that uses the dedicated surface for
 displaying OpenGL rendering.
 <p>
 A GLSurfaceView provides the following features:
 <p>
 <ul>
 <li>Manages a surface, which is a special piece of memory that can be
 composited into the Android view system.
 <li>Manages an EGL display, which enables OpenGL to render into a surface.
 <li>Accepts a user-provided Renderer object that does the actual rendering.
 <li>Renders on a dedicated thread to decouple rendering performance from the
 UI thread.
 <li>Supports both on-demand and continuous rendering.
 <li>Optionally wraps, traces, and/or error-checks the renderer'MAGIC_CONSTANT OpenGL
 calls.
 </ul>
 
 <h3>Using GLSurfaceView</h3>
 <p>
 Typically you use GLSurfaceView by subclassing it and overriding one or more
 of the View system input event methods. If your application does not need to
 override event methods then GLSurfaceView can be used as-is. For the most
 part GLSurfaceView behavior is customized by calling "set" methods rather
 than by subclassing. For example, unlike a regular View, drawing is delegated
 to a separate Renderer object which is registered with the GLSurfaceView
 using the <A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#setRenderer(org.anddev.andengine.opengl.view.GLSurfaceView.Renderer)"><CODE>setRenderer(Renderer)</CODE></A> call.
 <p>
 <h3>Initializing GLSurfaceView</h3>
 All you have to do to initialize a GLSurfaceView is call
 <A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#setRenderer(org.anddev.andengine.opengl.view.GLSurfaceView.Renderer)"><CODE>setRenderer(Renderer)</CODE></A>. However, if desired, you can modify the
 default behavior of GLSurfaceView by calling one or more of these methods
 before calling setRenderer:
 <ul>
 <li><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#setDebugFlags(int)"><CODE>setDebugFlags(int)</CODE></A>
 <li><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#setEGLConfigChooser(boolean)"><CODE>setEGLConfigChooser(boolean)</CODE></A>
 <li><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#setEGLConfigChooser(org.anddev.andengine.opengl.view.EGLConfigChooser)"><CODE>setEGLConfigChooser(EGLConfigChooser)</CODE></A>
 <li><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#setEGLConfigChooser(int, int, int, int, int, int)"><CODE>setEGLConfigChooser(int, int, int, int, int, int)</CODE></A>
 <li><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#setGLWrapper(org.anddev.andengine.opengl.view.GLWrapper)"><CODE>setGLWrapper(GLWrapper)</CODE></A>
 </ul>
 <p>
 <h4>Choosing an EGL Configuration</h4>
 A given Android device may support multiple possible types of drawing
 surfaces. The available surfaces may differ in how may channels of data are
 present, as well as how many bits are allocated to each channel. Therefore,
 the first thing GLSurfaceView has to do when starting to render is choose
 what type of surface to use.
 <p>
 By default GLSurfaceView chooses an available surface that'MAGIC_CONSTANT closest to a
 16-bit R5G6B5 surface with a 16-bit depth buffer and no stencil. If you would
 prefer a different surface (for example, if you do not need a depth buffer)
 you can override the default behavior by calling one of the
 setEGLConfigChooser methods.
 <p>
 <h4>Debug Behavior</h4>
 You can optionally modify the behavior of GLSurfaceView by calling one or
 more of the debugging methods <A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#setDebugFlags(int)"><CODE>setDebugFlags(int)</CODE></A>, and
 <A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#setGLWrapper(org.anddev.andengine.opengl.view.GLWrapper)"><CODE>setGLWrapper(org.anddev.andengine.opengl.view.GLWrapper)</CODE></A>. These methods may be called before and/or after
 setRenderer, but typically they are called before setRenderer so that they
 take effect immediately.
 <p>
 <h4>Setting a Renderer</h4>
 Finally, you must call <A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#setRenderer(org.anddev.andengine.opengl.view.GLSurfaceView.Renderer)"><CODE>setRenderer(org.anddev.andengine.opengl.view.GLSurfaceView.Renderer)</CODE></A> to register a <A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.Renderer.html" title="interface in org.anddev.andengine.opengl.view"><CODE>GLSurfaceView.Renderer</CODE></A>.
 The renderer is responsible for doing the actual OpenGL rendering.
 <p>
 <h3>Rendering Mode</h3>
 Once the renderer is set, you can control whether the renderer draws
 continuously or on-demand by calling <A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#setRenderMode(int)"><CODE>setRenderMode(int)</CODE></A>. The default is
 continuous rendering.
 <p>
 <h3>Activity Life-cycle</h3>
 A GLSurfaceView must be notified when the activity is paused and resumed.
 GLSurfaceView clients are required to call <A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#onPause()"><CODE>onPause()</CODE></A> when the
 activity pauses and <A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#onResume()"><CODE>onResume()</CODE></A> when the activity resumes. These
 calls allow GLSurfaceView to pause and resume the rendering thread, and also
 allow GLSurfaceView to release and recreate the OpenGL display.
 <p>
 <h3>Handling events</h3>
 <p>
 To handle an event you will typically subclass GLSurfaceView and override the
 appropriate method, just as you would with any other View. However, when
 handling the event, you may need to communicate with the Renderer object
 that'MAGIC_CONSTANT running in the rendering thread. You can do this using any standard
 Java cross-thread communication mechanism. In addition, one relatively easy
 way to communicate with your renderer is to call
 <A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#queueEvent(java.lang.Runnable)"><CODE>queueEvent(Runnable)</CODE></A>. For example:
 
 <pre class="prettyprint">
 class MyGLSurfaceView extends GLSurfaceView {
 
        private MyRenderer mMyRenderer;
 
        public void start() {
         mMyRenderer = ...;
         setRenderer(mMyRenderer);
     }
 
        public boolean onKeyDown(int keyCode, KeyEvent event) {
                if(keyCode == KeyEvent.KEYCODE_DPAD_CENTER) {
                        queueEvent(new Runnable() {
                                // This method will be called on the rendering
                                // thread:
                                public void run() {
                                        mMyRenderer.handleDpadCenter();
                                }
                        });
                        return true;
                }
                return super.onKeyDown(keyCode, event);
        }
 }
 </pre>
<P>

<P>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->

<A NAME="nested_class_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Nested Class Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) &nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.EglHelper.html" title="class in org.anddev.andengine.opengl.view">GLSurfaceView.EglHelper</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;An EGL helper class.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) &nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.GLThread.html" title="class in org.anddev.andengine.opengl.view">GLSurfaceView.GLThread</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A generic GL Thread.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;interface</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.Renderer.html" title="interface in org.anddev.andengine.opengl.view">GLSurfaceView.Renderer</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A generic renderer interface.</TD>
</TR>
</TABLE>
&nbsp;<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Field Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#DEBUG_CHECK_GL_ERROR">DEBUG_CHECK_GL_ERROR</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Check glError() after every GL call and throw an exception if glError
 indicates that an error has occurred.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#DEBUG_LOG_GL_CALLS">DEBUG_LOG_GL_CALLS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Log GL calls to the system log at "verbose" level with tag
 "GLSurfaceView".</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#mDebugFlags">mDebugFlags</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;<A HREF="../../../../../org/anddev/andengine/opengl/view/EGLConfigChooser.html" title="interface in org.anddev.andengine.opengl.view">EGLConfigChooser</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#mEGLConfigChooser">mEGLConfigChooser</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;<A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.GLThread.html" title="class in org.anddev.andengine.opengl.view">GLSurfaceView.GLThread</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#mGLThread">mGLThread</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;<A HREF="../../../../../org/anddev/andengine/opengl/view/GLWrapper.html" title="interface in org.anddev.andengine.opengl.view">GLWrapper</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#mGLWrapper">mGLWrapper</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#mHasSurface">mHasSurface</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;<A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.Renderer.html" title="interface in org.anddev.andengine.opengl.view">GLSurfaceView.Renderer</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#mRenderer">mRenderer</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#mRenderMode">mRenderMode</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#mSurfaceHeight">mSurfaceHeight</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#mSurfaceWidth">mSurfaceWidth</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#RENDERMODE_CONTINUOUSLY">RENDERMODE_CONTINUOUSLY</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The renderer is called continuously to re-render the scene.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#RENDERMODE_WHEN_DIRTY">RENDERMODE_WHEN_DIRTY</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The renderer only renders when the surface is created, or when
 <A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#requestRender()"><CODE>requestRender()</CODE></A> is called.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private static&nbsp;java.util.concurrent.Semaphore</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#sEglSemaphore">sEglSemaphore</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#GLSurfaceView(Context)">GLSurfaceView</A></B>(Context&nbsp;context)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Standard View constructor.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#GLSurfaceView(Context, AttributeSet)">GLSurfaceView</A></B>(Context&nbsp;context,
              AttributeSet&nbsp;attrs)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Standard View constructor.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#getDebugFlags()">getDebugFlags</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the current value of the debug flags.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#getRenderMode()">getRenderMode</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the current rendering mode.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#init()">init</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#onPause()">onPause</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Inform the view that the activity is paused.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#onResume()">onResume</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Inform the view that the activity is resumed.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#queueEvent(java.lang.Runnable)">queueEvent</A></B>(java.lang.Runnable&nbsp;r)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Queue a runnable to be run on the GL rendering thread.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#requestRender()">requestRender</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Request that the renderer render a frame.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#setDebugFlags(int)">setDebugFlags</A></B>(int&nbsp;debugFlags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the debug flags to a new value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#setEGLConfigChooser(boolean)">setEGLConfigChooser</A></B>(boolean&nbsp;needDepth)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Install a config chooser which will choose a config as close to 16-bit
 RGB as possible, with or without an optional depth buffer as close to
 16-bits as possible.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#setEGLConfigChooser(org.anddev.andengine.opengl.view.EGLConfigChooser)">setEGLConfigChooser</A></B>(<A HREF="../../../../../org/anddev/andengine/opengl/view/EGLConfigChooser.html" title="interface in org.anddev.andengine.opengl.view">EGLConfigChooser</A>&nbsp;configChooser)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Install a custom EGLConfigChooser.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#setEGLConfigChooser(int, int, int, int, int, int)">setEGLConfigChooser</A></B>(int&nbsp;redSize,
                    int&nbsp;greenSize,
                    int&nbsp;blueSize,
                    int&nbsp;alphaSize,
                    int&nbsp;depthSize,
                    int&nbsp;stencilSize)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Install a config chooser which will choose a config with at least the
 specified component sizes, and as close to the specified component sizes
 as possible.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#setGLWrapper(org.anddev.andengine.opengl.view.GLWrapper)">setGLWrapper</A></B>(<A HREF="../../../../../org/anddev/andengine/opengl/view/GLWrapper.html" title="interface in org.anddev.andengine.opengl.view">GLWrapper</A>&nbsp;glWrapper)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the glWrapper.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#setRenderer(org.anddev.andengine.opengl.view.GLSurfaceView.Renderer)">setRenderer</A></B>(<A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.Renderer.html" title="interface in org.anddev.andengine.opengl.view">GLSurfaceView.Renderer</A>&nbsp;renderer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the renderer associated with this view.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#setRenderMode(int)">setRenderMode</A></B>(int&nbsp;renderMode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the rendering mode.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#surfaceChanged(SurfaceHolder, int, int, int)">surfaceChanged</A></B>(SurfaceHolder&nbsp;holder,
               int&nbsp;format,
               int&nbsp;w,
               int&nbsp;h)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method is part of the SurfaceHolder.Callback interface, and is not
 normally called or subclassed by clients of GLSurfaceView.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#surfaceCreated(SurfaceHolder)">surfaceCreated</A></B>(SurfaceHolder&nbsp;holder)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method is part of the SurfaceHolder.Callback interface, and is not
 normally called or subclassed by clients of GLSurfaceView.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#surfaceDestroyed(SurfaceHolder)">surfaceDestroyed</A></B>(SurfaceHolder&nbsp;holder)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method is part of the SurfaceHolder.Callback interface, and is not
 normally called or subclassed by clients of GLSurfaceView.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Field Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="RENDERMODE_WHEN_DIRTY"><!-- --></A><H3>
RENDERMODE_WHEN_DIRTY</H3>
<PRE>
public static final int <B>RENDERMODE_WHEN_DIRTY</B></PRE>
<DL>
<DD>The renderer only renders when the surface is created, or when
 <A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#requestRender()"><CODE>requestRender()</CODE></A> is called.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#getRenderMode()"><CODE>getRenderMode()</CODE></A>, 
<A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#setRenderMode(int)"><CODE>setRenderMode(int)</CODE></A>, 
<A HREF="../../../../../constant-values.html#org.anddev.andengine.opengl.view.GLSurfaceView.RENDERMODE_WHEN_DIRTY">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="RENDERMODE_CONTINUOUSLY"><!-- --></A><H3>
RENDERMODE_CONTINUOUSLY</H3>
<PRE>
public static final int <B>RENDERMODE_CONTINUOUSLY</B></PRE>
<DL>
<DD>The renderer is called continuously to re-render the scene.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#getRenderMode()"><CODE>getRenderMode()</CODE></A>, 
<A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#setRenderMode(int)"><CODE>setRenderMode(int)</CODE></A>, 
<A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#requestRender()"><CODE>requestRender()</CODE></A>, 
<A HREF="../../../../../constant-values.html#org.anddev.andengine.opengl.view.GLSurfaceView.RENDERMODE_CONTINUOUSLY">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="DEBUG_CHECK_GL_ERROR"><!-- --></A><H3>
DEBUG_CHECK_GL_ERROR</H3>
<PRE>
public static final int <B>DEBUG_CHECK_GL_ERROR</B></PRE>
<DL>
<DD>Check glError() after every GL call and throw an exception if glError
 indicates that an error has occurred. This can be used to help track down
 which OpenGL ES call is causing an error.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#getDebugFlags()"><CODE>getDebugFlags()</CODE></A>, 
<A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#setDebugFlags(int)"><CODE>setDebugFlags(int)</CODE></A>, 
<A HREF="../../../../../constant-values.html#org.anddev.andengine.opengl.view.GLSurfaceView.DEBUG_CHECK_GL_ERROR">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="DEBUG_LOG_GL_CALLS"><!-- --></A><H3>
DEBUG_LOG_GL_CALLS</H3>
<PRE>
public static final int <B>DEBUG_LOG_GL_CALLS</B></PRE>
<DL>
<DD>Log GL calls to the system log at "verbose" level with tag
 "GLSurfaceView".
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#getDebugFlags()"><CODE>getDebugFlags()</CODE></A>, 
<A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#setDebugFlags(int)"><CODE>setDebugFlags(int)</CODE></A>, 
<A HREF="../../../../../constant-values.html#org.anddev.andengine.opengl.view.GLSurfaceView.DEBUG_LOG_GL_CALLS">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="sEglSemaphore"><!-- --></A><H3>
sEglSemaphore</H3>
<PRE>
private static final java.util.concurrent.Semaphore <B>sEglSemaphore</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="mGLThread"><!-- --></A><H3>
mGLThread</H3>
<PRE>
private <A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.GLThread.html" title="class in org.anddev.andengine.opengl.view">GLSurfaceView.GLThread</A> <B>mGLThread</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="mEGLConfigChooser"><!-- --></A><H3>
mEGLConfigChooser</H3>
<PRE>
private <A HREF="../../../../../org/anddev/andengine/opengl/view/EGLConfigChooser.html" title="interface in org.anddev.andengine.opengl.view">EGLConfigChooser</A> <B>mEGLConfigChooser</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="mGLWrapper"><!-- --></A><H3>
mGLWrapper</H3>
<PRE>
private <A HREF="../../../../../org/anddev/andengine/opengl/view/GLWrapper.html" title="interface in org.anddev.andengine.opengl.view">GLWrapper</A> <B>mGLWrapper</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="mDebugFlags"><!-- --></A><H3>
mDebugFlags</H3>
<PRE>
private int <B>mDebugFlags</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="mRenderMode"><!-- --></A><H3>
mRenderMode</H3>
<PRE>
private int <B>mRenderMode</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="mRenderer"><!-- --></A><H3>
mRenderer</H3>
<PRE>
private <A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.Renderer.html" title="interface in org.anddev.andengine.opengl.view">GLSurfaceView.Renderer</A> <B>mRenderer</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="mSurfaceWidth"><!-- --></A><H3>
mSurfaceWidth</H3>
<PRE>
private int <B>mSurfaceWidth</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="mSurfaceHeight"><!-- --></A><H3>
mSurfaceHeight</H3>
<PRE>
private int <B>mSurfaceHeight</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="mHasSurface"><!-- --></A><H3>
mHasSurface</H3>
<PRE>
private boolean <B>mHasSurface</B></PRE>
<DL>
<DL>
</DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="GLSurfaceView(Context)"><!-- --></A><H3>
GLSurfaceView</H3>
<PRE>
public <B>GLSurfaceView</B>(Context&nbsp;context)</PRE>
<DL>
<DD>Standard View constructor. In order to render something, you must call
 <A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#setRenderer(org.anddev.andengine.opengl.view.GLSurfaceView.Renderer)"><CODE>setRenderer(org.anddev.andengine.opengl.view.GLSurfaceView.Renderer)</CODE></A> to register a renderer.
<P>
</DL>
<HR>

<A NAME="GLSurfaceView(Context, AttributeSet)"><!-- --></A><H3>
GLSurfaceView</H3>
<PRE>
public <B>GLSurfaceView</B>(Context&nbsp;context,
                     AttributeSet&nbsp;attrs)</PRE>
<DL>
<DD>Standard View constructor. In order to render something, you must call
 <A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#setRenderer(org.anddev.andengine.opengl.view.GLSurfaceView.Renderer)"><CODE>setRenderer(org.anddev.andengine.opengl.view.GLSurfaceView.Renderer)</CODE></A> to register a renderer.
<P>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="init()"><!-- --></A><H3>
init</H3>
<PRE>
private void <B>init</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setGLWrapper(org.anddev.andengine.opengl.view.GLWrapper)"><!-- --></A><H3>
setGLWrapper</H3>
<PRE>
public void <B>setGLWrapper</B>(<A HREF="../../../../../org/anddev/andengine/opengl/view/GLWrapper.html" title="interface in org.anddev.andengine.opengl.view">GLWrapper</A>&nbsp;glWrapper)</PRE>
<DL>
<DD>Set the glWrapper. If the glWrapper is not null, its
 <A HREF="../../../../../org/anddev/andengine/opengl/view/GLWrapper.html#wrap(GL)"><CODE>GLWrapper.wrap(GL)</CODE></A> method is called whenever a surface is
 created. A GLWrapper can be used to wrap the GL object that'MAGIC_CONSTANT passed to
 the renderer. Wrapping a GL object enables examining and modifying the
 behavior of the GL calls made by the renderer.
 <p>
 Wrapping is typically used for debugging purposes.
 <p>
 The default value is null.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>glWrapper</CODE> - the new GLWrapper</DL>
</DD>
</DL>
<HR>

<A NAME="setDebugFlags(int)"><!-- --></A><H3>
setDebugFlags</H3>
<PRE>
public void <B>setDebugFlags</B>(int&nbsp;debugFlags)</PRE>
<DL>
<DD>Set the debug flags to a new value. The value is constructed by
 OR-together zero or more of the DEBUG_CHECK_* constants. The debug flags
 take effect whenever a surface is created. The default value is zero.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>debugFlags</CODE> - the new debug flags<DT><B>See Also:</B><DD><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#DEBUG_CHECK_GL_ERROR"><CODE>DEBUG_CHECK_GL_ERROR</CODE></A>, 
<A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#DEBUG_LOG_GL_CALLS"><CODE>DEBUG_LOG_GL_CALLS</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getDebugFlags()"><!-- --></A><H3>
getDebugFlags</H3>
<PRE>
public int <B>getDebugFlags</B>()</PRE>
<DL>
<DD>Get the current value of the debug flags.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the current value of the debug flags.</DL>
</DD>
</DL>
<HR>

<A NAME="setRenderer(org.anddev.andengine.opengl.view.GLSurfaceView.Renderer)"><!-- --></A><H3>
setRenderer</H3>
<PRE>
public void <B>setRenderer</B>(<A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.Renderer.html" title="interface in org.anddev.andengine.opengl.view">GLSurfaceView.Renderer</A>&nbsp;renderer)</PRE>
<DL>
<DD>Set the renderer associated with this view. Also starts the thread that
 will call the renderer, which in turn causes the rendering to start.
 <p>
 This method should be called once and only once in the life-cycle of a
 GLSurfaceView.
 <p>
 The following GLSurfaceView methods can only be called <em>before</em>
 setRenderer is called:
 <ul>
 <li><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#setEGLConfigChooser(boolean)"><CODE>setEGLConfigChooser(boolean)</CODE></A>
 <li><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#setEGLConfigChooser(org.anddev.andengine.opengl.view.EGLConfigChooser)"><CODE>setEGLConfigChooser(EGLConfigChooser)</CODE></A>
 <li><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#setEGLConfigChooser(int, int, int, int, int, int)"><CODE>setEGLConfigChooser(int, int, int, int, int, int)</CODE></A>
 </ul>
 <p>
 The following GLSurfaceView methods can only be called <em>after</em>
 setRenderer is called:
 <ul>
 <li><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#getRenderMode()"><CODE>getRenderMode()</CODE></A>
 <li><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#onPause()"><CODE>onPause()</CODE></A>
 <li><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#onResume()"><CODE>onResume()</CODE></A>
 <li><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#queueEvent(java.lang.Runnable)"><CODE>queueEvent(Runnable)</CODE></A>
 <li><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#requestRender()"><CODE>requestRender()</CODE></A>
 <li><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#setRenderMode(int)"><CODE>setRenderMode(int)</CODE></A>
 </ul>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>renderer</CODE> - the renderer to use to perform OpenGL drawing.</DL>
</DD>
</DL>
<HR>

<A NAME="setEGLConfigChooser(org.anddev.andengine.opengl.view.EGLConfigChooser)"><!-- --></A><H3>
setEGLConfigChooser</H3>
<PRE>
public void <B>setEGLConfigChooser</B>(<A HREF="../../../../../org/anddev/andengine/opengl/view/EGLConfigChooser.html" title="interface in org.anddev.andengine.opengl.view">EGLConfigChooser</A>&nbsp;configChooser)</PRE>
<DL>
<DD>Install a custom EGLConfigChooser.
 <p>
 If this method is called, it must be called before
 <A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#setRenderer(org.anddev.andengine.opengl.view.GLSurfaceView.Renderer)"><CODE>setRenderer(Renderer)</CODE></A> is called.
 <p>
 If no setEGLConfigChooser method is called, then by default the view will
 choose a config as close to 16-bit RGB as possible, with a depth buffer
 as close to 16 bits as possible.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>configChooser</CODE> - </DL>
</DD>
</DL>
<HR>

<A NAME="setEGLConfigChooser(boolean)"><!-- --></A><H3>
setEGLConfigChooser</H3>
<PRE>
public void <B>setEGLConfigChooser</B>(boolean&nbsp;needDepth)</PRE>
<DL>
<DD>Install a config chooser which will choose a config as close to 16-bit
 RGB as possible, with or without an optional depth buffer as close to
 16-bits as possible.
 <p>
 If this method is called, it must be called before
 <A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#setRenderer(org.anddev.andengine.opengl.view.GLSurfaceView.Renderer)"><CODE>setRenderer(Renderer)</CODE></A> is called.
 <p>
 If no setEGLConfigChooser method is called, then by default the view will
 choose a config as close to 16-bit RGB as possible, with a depth buffer
 as close to 16 bits as possible.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>needDepth</CODE> - </DL>
</DD>
</DL>
<HR>

<A NAME="setEGLConfigChooser(int, int, int, int, int, int)"><!-- --></A><H3>
setEGLConfigChooser</H3>
<PRE>
public void <B>setEGLConfigChooser</B>(int&nbsp;redSize,
                                int&nbsp;greenSize,
                                int&nbsp;blueSize,
                                int&nbsp;alphaSize,
                                int&nbsp;depthSize,
                                int&nbsp;stencilSize)</PRE>
<DL>
<DD>Install a config chooser which will choose a config with at least the
 specified component sizes, and as close to the specified component sizes
 as possible.
 <p>
 If this method is called, it must be called before
 <A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#setRenderer(org.anddev.andengine.opengl.view.GLSurfaceView.Renderer)"><CODE>setRenderer(Renderer)</CODE></A> is called.
 <p>
 If no setEGLConfigChooser method is called, then by default the view will
 choose a config as close to 16-bit RGB as possible, with a depth buffer
 as close to 16 bits as possible.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setRenderMode(int)"><!-- --></A><H3>
setRenderMode</H3>
<PRE>
public void <B>setRenderMode</B>(int&nbsp;renderMode)</PRE>
<DL>
<DD>Set the rendering mode. When renderMode is RENDERMODE_CONTINUOUSLY, the
 renderer is called repeatedly to re-render the scene. When renderMode is
 RENDERMODE_WHEN_DIRTY, the renderer only rendered when the surface is
 created, or when <A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#requestRender()"><CODE>requestRender()</CODE></A> is called. Defaults to
 RENDERMODE_CONTINUOUSLY.
 <p>
 Using RENDERMODE_WHEN_DIRTY can improve battery life and overall system
 performance by allowing the GPU and CPU to idle when the view does not
 need to be updated.
 <p>
 This method can only be called after <A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#setRenderer(org.anddev.andengine.opengl.view.GLSurfaceView.Renderer)"><CODE>setRenderer(Renderer)</CODE></A>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>renderMode</CODE> - one of the RENDERMODE_X constants<DT><B>See Also:</B><DD><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#RENDERMODE_CONTINUOUSLY"><CODE>RENDERMODE_CONTINUOUSLY</CODE></A>, 
<A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#RENDERMODE_WHEN_DIRTY"><CODE>RENDERMODE_WHEN_DIRTY</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getRenderMode()"><!-- --></A><H3>
getRenderMode</H3>
<PRE>
public int <B>getRenderMode</B>()</PRE>
<DL>
<DD>Get the current rendering mode. May be called from any thread. Must not
 be called before a renderer has been set.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the current rendering mode.<DT><B>See Also:</B><DD><A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#RENDERMODE_CONTINUOUSLY"><CODE>RENDERMODE_CONTINUOUSLY</CODE></A>, 
<A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#RENDERMODE_WHEN_DIRTY"><CODE>RENDERMODE_WHEN_DIRTY</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="requestRender()"><!-- --></A><H3>
requestRender</H3>
<PRE>
public void <B>requestRender</B>()</PRE>
<DL>
<DD>Request that the renderer render a frame. This method is typically used
 when the render mode has been set to <A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.html#RENDERMODE_WHEN_DIRTY"><CODE>RENDERMODE_WHEN_DIRTY</CODE></A>, so
 that frames are only rendered on demand. May be called from any thread.
 Must be called after onResume() and before onPause().
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="surfaceCreated(SurfaceHolder)"><!-- --></A><H3>
surfaceCreated</H3>
<PRE>
public void <B>surfaceCreated</B>(SurfaceHolder&nbsp;holder)</PRE>
<DL>
<DD>This method is part of the SurfaceHolder.Callback interface, and is not
 normally called or subclassed by clients of GLSurfaceView.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="surfaceDestroyed(SurfaceHolder)"><!-- --></A><H3>
surfaceDestroyed</H3>
<PRE>
public void <B>surfaceDestroyed</B>(SurfaceHolder&nbsp;holder)</PRE>
<DL>
<DD>This method is part of the SurfaceHolder.Callback interface, and is not
 normally called or subclassed by clients of GLSurfaceView.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="surfaceChanged(SurfaceHolder, int, int, int)"><!-- --></A><H3>
surfaceChanged</H3>
<PRE>
public void <B>surfaceChanged</B>(SurfaceHolder&nbsp;holder,
                           int&nbsp;format,
                           int&nbsp;w,
                           int&nbsp;h)</PRE>
<DL>
<DD>This method is part of the SurfaceHolder.Callback interface, and is not
 normally called or subclassed by clients of GLSurfaceView.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="onPause()"><!-- --></A><H3>
onPause</H3>
<PRE>
public void <B>onPause</B>()</PRE>
<DL>
<DD>Inform the view that the activity is paused. The owner of this view must
 call this method when the activity is paused. Calling this method will
 pause the rendering thread. Must not be called before a renderer has been
 set.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="onResume()"><!-- --></A><H3>
onResume</H3>
<PRE>
public void <B>onResume</B>()</PRE>
<DL>
<DD>Inform the view that the activity is resumed. The owner of this view must
 call this method when the activity is resumed. Calling this method will
 recreate the OpenGL display and resume the rendering thread. Must not be
 called before a renderer has been set.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="queueEvent(java.lang.Runnable)"><!-- --></A><H3>
queueEvent</H3>
<PRE>
public void <B>queueEvent</B>(java.lang.Runnable&nbsp;r)</PRE>
<DL>
<DD>Queue a runnable to be run on the GL rendering thread. This can be used
 to communicate with the Renderer on the rendering thread. Must be called
 after onResume() and before onPause().
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>r</CODE> - the runnable to be run on the GL rendering thread.</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/GLSurfaceView.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../../org/anddev/andengine/opengl/view/EGLConfigChooser.html" title="interface in org.anddev.andengine.opengl.view"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../../../org/anddev/andengine/opengl/view/GLSurfaceView.EglHelper.html" title="class in org.anddev.andengine.opengl.view"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../../index.html?org/anddev/andengine/opengl/view/GLSurfaceView.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="GLSurfaceView.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;<A HREF="#nested_class_summary">NESTED</A>&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
